---
title: "Esmerald. Experience sampling made easy."
author: "M Schmettow"
date: "19/02/2021"
output: html_document
---

```{r setup}
library(tidyverse)
library(lubridate)
library(esmerald)
```

# Import

Character vector of csv files

```{r}
csv <- dir("../inst/extdata/",full.names = T)[2:9]
```

Reading a single file

```{r}
ESM_1 <- 
  read_ethica_csv("../inst/extdata/survey_responses_5716.csv")
```

The result is a table of class *tbl_esm*.

```{r}
class(ESM_1)
```

But the fact that we use S3 classes shouldn't bother you. It just makes it easier for us to create a convenient interface. For example, if you just call the ESM_1 object like this:

```{r eval = F}
ESM_1
```

you get a useful summary of the data set:

```{r echo = F}
ESM_1
```

ESM_1 is in long format. Every measure gets its own row. The long format also makes it very easy to combine a group of files into one ESM table. If you know a little programming already, you might think that processing a list of objects requires a loop. In R, this is much easier. `map_df` takes a list of file names as input, applies the function `read_ethica_csv` a number of times and merges the results into  one ESM table.


```{r}
ESM_2 <- 
  csv[2:6] %>% 
  map_df(read_ethica_csv)
ESM_2
```


The `plot` command provides an overview of the data.

```{r fig.height = 12}
plot(ESM_2)
```

# Adding meta data

We export a table to add the meta data:

```{r}
ESM_2 %>% 
  export_item_labels() %>% 
  write_csv(file = "ESM_2_Scales.csv")
```

After editing, we join it back:

```{r}
ESM_2_1 <- 
read_csv("../inst/extdata/ESM_2_Scales.csv") %>% 
  select(-Activity) %>% 
  right_join(ESM_2, by = "Item_raw") %>% 
  mutate(response = mascutils::rescale_unit(response),
         response = if_else(reverse == T,
                            1 - response,
                            response))
```



# Reporting

We compute the mean response per participant and do correlations

```{r}
ESM_2_1 %>% 
  group_by(Part, Scale) %>% 
  summarize(mean_resp = mean(response, na.rm = T)) %>% 
  ungroup() %>% 
  pivot_wider(names_from = Scale, values_from = mean_resp) %>% 
  select(-Part) %>% 
  GGally::ggpairs()
```

We do a mean response per Part, Scale and T_Scheduled and plot a time series

```{r fig.height = 12}
ESM_2_1 %>% 
  filter(str_detect(Scale, "^state")) %>% 
  group_by(Part, Scale, T_Scheduled) %>% 
  summarize(mean_resp = mean(response, na.rm = T)) %>% 
  ungroup() %>% 
  ggplot(aes(x = T_Scheduled,
             y = mean_resp,
             col = Scale)) +
  geom_smooth(se = F) +
  facet_wrap(Part ~ .)
```


# Modelling



